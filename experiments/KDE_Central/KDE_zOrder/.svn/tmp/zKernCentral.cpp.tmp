#include <iostream>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <climits>
#include <vector>
#include <math.h>
#include <algorithm>
#include "mtimer.h"

using namespace std;

typedef struct zRec {
   zRec( long inZ, float inx, float iny ) {
      z = inZ;
      x = inx;
      y = iny;
   }

   unsigned long z;
   float x, y;
} zRec;

bool zComp (zRec z1, zRec z2) { return (z1.z < z2.z); }

int toScaledInt( float f ) {
        int scale = 1000;

        int intpart = (int) f;
        float floatpart = f;

        floatpart = floatpart - intpart;
        intpart *= scale;
        intpart += (int) ( floatpart * scale );

        return intpart;
}

unsigned int shift( int coord, int shift ) {
        unsigned int result = (unsigned int) ( coord + shift );
        return result;
}


unsigned long zValue( unsigned int x, unsigned int y ) {
   unsigned long z = 0;
   for (int i = 0; i < sizeof(x) * CHAR_BIT; i++)
   {
     z |= (x & 1U << i) << (i+1) | (y & 1U << i) << i;
   }
}

int main(int argc, char** argv) {

        if( argc != 4) {
           cout << "use: " << argv[0] << " infile outfile epsilon" << endl;
           return 0;
        }

        MTimer mt;
        mt.go();

        srand(time(0));
	ifstream fin( argv[1] );
	ofstream fout( argv[2] );
        double eps = atof( argv[3] );
        double k = ceil( (4.0/eps) * sqrt( log( 4.0 / eps ) )*log( 4.0 / eps ) );
        vector<zRec> zVec;
        int s1 = rand() % ( UINT_MAX - 200000 );
        int s2 = rand() % ( UINT_MAX - 200000 );

	char c[2048];
        float f1, f2;
        int i1, i2;
        unsigned int u1, u2;
	while( fin >> f1 >> f2) {
           fin.getline( c, 2048 );
           
           i1 = toScaledInt( f1 );
           i2 = toScaledInt( f2 );
           u1 = shift( i1, s1 );
           u2 = shift( i2, s2 );

           zRec rec( zValue( u1, u2 ), f1, f2 );
           zVec.push_back( rec );    
	}

        sort( zVec.begin(), zVec.end(), zComp );

        int skipLength = (int) floor( ( (double) zVec.size() - k ) / ( k - 1.0 ) );
        if( skipLength == 0 ) skipLength = 1;

        for( int j = 0; j < zVec.size(); j += skipLength ) {
           fout << zVec[j].x << ' ' << zVec[j].y << '\n';
        }

	fin.close();
	fout.close();
        mt.stop();
        mt.update();

        cout << mt.elapsed << '\n';

}
