#include <stdio.h>
#include <stdlib.h>
#include <sys/times.h>
#include "headers.h"
#include "mtimer.h"

// The data set containing all the points.
PPointT *dataSetPoints = NULL;
// Number of points in the data set.
IntT nPoints = 0;
// The dimension of the points.
IntT pointsDimension = 0;
// RealT
RealT t;

PPointMatchStructT pmStruct;
/*
  Prints the usage of the LSHMain.
 */
void usage(char *programName){
  printf("Usage: %s #pts_in_data_set dimension  data_set_file t_value\n", programName);
}
inline RealT diffclock(clock_t clock1,clock_t clock2)
{
    RealT diffticks=clock1-clock2;
    RealT diffms=(diffticks)/CLOCKS_PER_SEC;
    return diffms;
}

inline PPointT readPoint(FILE *fileHandle){
  PPointT p;
  RealT sqrLength = 0;
  FAILIF(NULL == (p = (PPointT)MALLOC(sizeof(PointT))));
  FAILIF(NULL == (p->coordinates = (RealT*)MALLOC(pointsDimension * sizeof(RealT))));
  for(IntT d = 0; d < pointsDimension; d++){
    FSCANF_REAL(fileHandle, &(p->coordinates[d]));
  }
  //fscanf(fileHandle, "%[^\n]", sBuffer);
  p->index = -1;
  return p;
}

inline void readPointRS(FILE *fileHandle){
  RealT dummy;
  for(IntT d = 0; d < pointsDimension; d++){
    FSCANF_REAL(fileHandle, &(dummy));
  }
}
// Reads in the data set points from <filename> in the array
// <dataSetPoints>. Each point get a unique number in the field
// <index> to be easily indentifiable.
void readDataSetFromFileRS(char *filename, int nRSample){
  FILE *f = fopen(filename, "rt");
  FAILIF(f == NULL);
  int dummy;
  RealT dummy1, dummy2;
  FAILIF(NULL == (dataSetPoints = (PPointT*)MALLOC(nRSample * sizeof(PPointT))));
  for(IntT i = 0; i < nRSample; i++){
    dataSetPoints[i] = readPoint(f);
    dataSetPoints[i]->index = i;
    dataSetPoints[i]->tag = 0;
    //printf("index = %d, first cord = %f\n",i,dataSetPoints[i]->coordinates[0]);
  }
  for(IntT i = nRSample; i < nPoints; i++){
	readPointRS(f);
	IntT r = genRandomInt(0,i);
	if(r<nRSample){
		free(dataSetPoints[r]);
		dataSetPoints[r] = readPoint(f);
	}
  } 
}


RealT** randSample(char *filename, int nRSample){
	RealT** sample;
	FILE *f = fopen(filename, "r");
  	FAILIF(f == NULL);
	FAILIF(NULL == (sample = (RealT**)MALLOC(sizeof(RealT*)*nRSample)));
	for(IntT i = 0; i < nRSample; i++){
		FAILIF(NULL == (sample[i] = (RealT*)MALLOC(sizeof(RealT)*pointsDimension)));
    	int dummy = fscanf(f, "%f %f", &sample[i][0], &sample[i][1]);
		//printf("index = %d, first cord = %f\n",i,dataSetPoints[i]->coordinates[0]);
  	}
	RealT data1, data2;
	for(IntT i = nRSample; i < nPoints; i++){
    int dummy = fscanf(f, "%f %f", &data1, &data2);
	IntT r = genRandomInt(0,i);
    if(r<nRSample){
    	sample[r][0] = data1;
		sample[r][1] = data2;
	}
  }
  return sample;

}

void printoutfile(PPointT* dataSetPoints, int nRSample){
	for(IntT i = 0 ; i<nRSample; i++){
		printf("i = %d, c1 = %f, c2 =%f\n",i,dataSetPoints[i]->coordinates[0],dataSetPoints[i]->coordinates[1]);
	}
}
void readDataSetFromFile(char *filename, RealT* minarr, RealT* maxarr){
  FILE *f = fopen(filename, "rt");
  FAILIF(f == NULL);
  RealT* cor;
  FAILIF(NULL == (dataSetPoints = (PPointT*)MALLOC(nPoints * sizeof(PPointT))));
  for(IntT i = 0; i < nPoints; i++){
    dataSetPoints[i] = readPoint(f);
    dataSetPoints[i]->index = i;
	cor = dataSetPoints[i]->coordinates;
    if(i == 0){
            for(IntT j = 0; j<pointsDimension; j++){
                minarr[j] = cor[j];
                maxarr[j] = cor[j];
            }
    }else{
            for(IntT j = 0; j<pointsDimension; j++){
                if(cor[j] < minarr[j]){
                    minarr[j] = cor[j];
                }
                if(cor[j] > maxarr[j]){
                    maxarr[j] = cor[j];
                }
            }
    }
    //printf("index = %d, first cord = %f\n",i,dataSetPoints[i]->coordinates[0]);
  }
}



void freeDataPoints(PPointT* dataSetPoints, IntT nPoints){
	PPointT p;
	for(IntT i = 0; i<nPoints; i++){
		p = dataSetPoints[i];
		if(p){
			free(p->coordinates);
			free(p);
		}
	}
	free(dataSetPoints);
}

void getFloatArrSample( PPointT *dataSet,IntT nPoints, IntT dim, char* file){
    FILE *fp = fopen(file,"w");
    //DPRINTF("nPoints = %d\n",nPoints);
    for(IntT i = 0; i<nPoints; i++){
        //FAILIF(NULL == (sample[i] = (RealT*)MALLOC(sizeof(RealT)*dim)));
        for(IntT j = 0; j<dim; j++){
            //sample[i][j] = dataSet[i]->coordinates[j];
            //DPRINTF4("i = %d,j=%d,sample[i][j]  = %f\n",i,j,sample[i][j]);
            fprintf(fp,"%f ",dataSet[i]->coordinates[j]);
        }
        fprintf(fp,"\n");
    }
    fclose(fp);
}


inline PPointT readPointFloat(RealT *singledata){
    PPointT p;
    FAILIF(NULL == (p = (PPointT)MALLOC(sizeof(PointT))));
    p->coordinates = singledata;
    p->index = -1;
    return p;
}

void readDataSetFromArray(RealT** data, int nRSample, RealT* minarr, RealT* maxarr){
	RealT* cor;
    FAILIF(NULL == (dataSetPoints = (PPointT*)MALLOC(nRSample * sizeof(PPointT))));
    for(IntT i = 0; i < nRSample; i++){
    	//printf("i = %d\n",i); 
	   dataSetPoints[i] = readPointFloat(data[i]);
        dataSetPoints[i]->index = i;
        dataSetPoints[i]->tag = 0;
		cor = data[i];
        if(i == 0){
            for(IntT j = 0; j<pointsDimension; j++){
                minarr[j] = cor[j];
                maxarr[j] = cor[j];
            }
        }else{
            for(IntT j = 0; j<pointsDimension; j++){
                if(cor[j] < minarr[j]){
                    minarr[j] = cor[j];
                }
                if(cor[j] > maxarr[j]){
                    maxarr[j] = cor[j];
                }
            }
        }
     }
}


int main(int nargs, char **args){
  	if(nargs < 5){
    	usage(args[0]);
    	exit(1);
 	 }
  	FILE *fp;
	FILE *tfp; 	
	clock_t begin;
	clock_t end;
  	// Parse part of the command-line parameters.
  	nPoints = atoi(args[1]);
	pointsDimension = atoi(args[2]);
    t = atof(args[4]);
	RealT eps = t; 

	RealT delta = 0.001;
	IntT nRSample = ceil( ( 1.0 / (eps*eps) ) * log( 1.0 / delta ) );

	MTimer verybegin;
    verybegin.go();
	
	initRandom();
	IntT originalnPoints;
	RealT* minarr;
    RealT* maxarr;
    FAILIF(NULL == (minarr = (RealT*)MALLOC(sizeof(RealT)*pointsDimension)));
    FAILIF(NULL == (maxarr = (RealT*)MALLOC(sizeof(RealT)*pointsDimension)));
	RealT** data;
	
	
	if(nRSample > nPoints){
		DPRINTF1("Don't need to do random sampling\n");
		readDataSetFromFile(args[3],minarr,maxarr);	
		originalnPoints = nPoints;
	}else{
		data = randSample(args[3],nRSample);
	    readDataSetFromArray(data,nRSample,minarr,maxarr);
		nPoints = nRSample;
		originalnPoints = nRSample;
	}
	PPointT *originalDataSet = dataSetPoints;
	IntT k = ceil(4/eps*sqrt(log(4/eps))*log(4/eps));
	//printf("nPoints = %d, k = %d\n",nPoints,k);
	if(k > nRSample){
 	   DPRINTF1("If we want to achieve eps, we can't do reduce, just use the original data\n");
	}
	IntT nofr = log(nPoints/k)/log(2);
	//printf("nofr = %d\n",nofr);
	RealT stderror = 0;
	RealT acc_err = 0;
	dataSetPoints = originalDataSet;
	//DPRINTF4("\nk = %d, number of round = %d, eps = %f\n", k, nofr,eps);

	for(IntT i = 0; i < nPoints; i++){
		dataSetPoints[i]->tag = 0;
	}
	stderror = 0;
	acc_err = 0;
	for(IntT v = 0; v<nofr;v++){

  		//acc_err += sqrt(log(nPoints))/nPoints;
  		//stderror = sqrt(log(nPoints))/nPoints;
  		pmStruct = newPMatchStructure(nPoints, pointsDimension,20000* t);
  		for(IntT i = 0; i<log(1/t)+2; i++){
			begin = clock();
            constructHash(i,pmStruct,dataSetPoints,minarr,maxarr);
            end = clock();
            RealT construct = RealT(diffclock(end,begin));
            getMatchPairs(pmStruct,dataSetPoints);
            begin = clock();
            RealT match = RealT(diffclock(begin,end));
            //DPRINTF5("v = %d, i = %d, construct = %f, match = %f\n",v,i,construct,match);
		}
  		matchArb(pmStruct,dataSetPoints);  
  		end = clock();
		//DPRINTF3("v = %d,arbmatch = %f\n",v,RealT(diffclock(end,begin)));
		if(v != 0){
			free(dataSetPoints);
		}
		//printf("new nPoints = %d\n",pmStruct->nMPoints);
		dataSetPoints =  getSamplePoint(pmStruct,originalDataSet,pointsDimension);
  		nPoints = pmStruct->nMPoints;
		begin=clock();
		//DPRINTF3("v = %d,getSample = %f\n",v,RealT(diffclock(begin,end)));
  //compute the error
  		if(v == nofr-1){
			verybegin.stop();
        	verybegin.update();
			printf("%f\n",verybegin.elapsed);
			getFloatArrSample(dataSetPoints,nPoints,pointsDimension,args[5]);
			//printf(" %f\n", RealT(diffclock(end,verybegin)));
   		}
  		freePMatchStructure(pmStruct);
		end = clock();	
		//DPRINTF3("v = %d,freePM = %f\n",v,RealT(diffclock(end,begin)));
	}
 	freeDataPoints(originalDataSet,originalnPoints);
	free(minarr);
    free(maxarr);
  	return 0;
}
